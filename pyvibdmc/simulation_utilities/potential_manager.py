import multiprocessing as mp
import os,sys
import numpy as np

class Potential:
    def __init__(self,
                 potential_function,
                 potential_dir,
                 pool=0
                 ):
        """
        A potential handler that is able to call python functions that
        call .so files, either generated by f2py or loaded in by ctypes.
        @param potential_function: The name of a python function (user specified) that will take in a n x m3 stack of
         geometries and return a 1D numpy array filled with potential values in hartrees.
        @type potential_function:str
        @param potential_dir: The *absolute path* to the directory that contains the .so file and .py file. If it's
        a python function, then just the absolute path to your .py file.
        @type:str
        @param pool: Will create a pool of <pool> processes using Python's multiprocessing module. This should never
        be larger than the number of processors on the machine this code is run.
        @type:int
        """
        self.pot_dir = potential_dir
        self.pot_func_name = potential_function
        self.pool = pool
        self.initalize()

    def initialize(self):
        if self.pool > 1:
            #initialize pool
            self._potPool = mp.Pool(self.pool)
        else:
            self._potPool = None
        self._init_pot()

    def _init_pot(self):
        import importlib
        """Go to potential directory that houses python function and assign a self._pot variable to it"""
        cur_dir = os.getcwd()
        os.chdir(self.pot_dir)
        sys.path.insert(0, self.pot_dir)
        self._pot = importlib.import_module(self.pot_func_name)
        os.chdir(cur_dir)

    def getpot(self,cds):
        """Uses the potential function we got to call potential"""
        if self._potPool is not None:
            cds = np.array_split(self.pool)
            res = self._potPool.map(self._pot,cds)
            v = np.concatenate((res))
        else:
            v = self._pot(cds)
        return v